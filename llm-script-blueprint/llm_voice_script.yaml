blueprint:
  name: LLM Script for Music Assistant voice requests
  source_url: https://github.com/markist/voice-support/blob/main/llm-script-blueprint/llm_voice_script.yaml
  description: Script with Auto-Power-On, Audiobook & Podcast Logic.
  domain: script
  author: TheFes (Modified by Gemini)
  homeassistant:
    min_version: 2024.6.0
  input:
    music_assistant_settings:
      name: Settings for Music Assistant playback
      icon: mdi:music
      description: Configure Music Assistant playback.
      input:
        default_player:
          name: Default Player
          description: Default MA player if none specified.
          selector:
            entity:
              filter:
              - integration: music_assistant
                domain:
                - media_player
              multiple: false
          default:
        play_continuously:
          name: Radio Mode
          description: Radio Mode settings.
          selector:
            select:
              options:
              - Use player settings
              - Always
              - Never
              multiple: false
              custom_value: false
              sort: false
          default: Use player settings
    prompt_settings:
      name: Prompt settings for the LLM
      icon: mdi:robot
      description: Fine-tune prompts.
      collapsed: true
      input:
        media_type_prompt:
          name: Media Type Prompt
          description: Prompt for media_type.
          selector:
            text:
              multiline: true
              multiple: false
          default: 'This argument is mandatory!
            "media_type" values:
            - "track"
            - "album"
            - "artist"
            - "playlist"
            - "radio"
            - "podcast"
            - "audiobook"
            If no match, use "playlist".'
        artist_prompt:
          name: Artist Prompt
          description: Prompt for artist.
          selector:
            text:
              multiline: true
              multiple: false
          default: '"artist" is the requested artist, or podcast host, or audiobook author. If unknown, use empty string.'
        album_prompt:
          name: Album Prompt
          description: Prompt for album.
          selector:
            text:
              multiline: true
              multiple: false
          default: '"album" is the requested album. If unknown, use empty string.'
        media_id_prompt:
          name: Media ID Prompt
          description: Prompt for media_id.
          selector:
            text:
              multiline: true
              multiple: false
          default: 'Mandatory!
            - track: track name
            - album: album name
            - artist: artist name
            - playlist: playlist name
            - radio: channel name
            - podcast: podcast name
            - audiobook: audiobook title'
        media_description_prompt:
          name: Media Description Prompt
          description: Prompt for media description.
          selector:
            text:
              multiline: true
              multiple: false
          default: Description of media to be played.
        area_prompt:
          name: Area Prompt
          description: Prompt for area.
          selector:
            text:
              multiline: true
              multiple: false
          default: The area(s) for the request.
        media_player_prompt:
          name: Media Player Prompt
          description: Prompt for media player.
          selector:
            text:
              multiline: true
              multiple: false
          default: Only use if specifically mentioned. Must be MA entity_id.
        shuffle_prompt:
          name: Shuffle Prompt
          description: Prompt for shuffle.
          selector:
            text:
              multiline: true
              multiple: false
          default: 'Mandatory! True if shuffle requested. False for Podcasts/Audiobooks.'
    addition_conditions_actions:
      name: Additional actions
      icon: mdi:wrench
      description: Additional actions after playback starts.
      collapsed: true
      input:
        actions:
          name: Additional actions
          selector:
            action: {}
          default: []
mode: parallel
max_exceeded: silent
description: Play music based on voice request (Auto-Power & Logic Fixes).
fields:
  media_type:
    selector:
      select:
        options:
        - track
        - album
        - artist
        - playlist
        - radio
        - podcast
        - audiobook
    name: Media Type
    description: !input media_type_prompt
    required: true
  artist:
    selector:
      text:
    name: Artist
    description: !input artist_prompt
    required: true
  album:
    selector:
      text:
    name: Album
    description: !input album_prompt
    required: true
  media_id:
    selector:
      text:
    name: Media ID
    description: !input media_id_prompt
    required: true
  media_description:
    selector:
      text:
    name: Media Description
    description: !input media_description_prompt
    required: true
  area:
    selector:
      area:
        entity:
          integration: music_assistant
          domain: media_player
        multiple: true
    name: Area
    description: !input area_prompt
  media_player:
    selector:
      entity:
        filter:
          integration: music_assistant
          domain: media_player
        multiple: true
    name: Media Player
    description: !input media_player_prompt
  shuffle:
    selector:
      boolean:
    name: Shuffle
    description: !input shuffle_prompt
sequence:
  - variables:
      # Inputs vorbereiten
      version: 20250103
      default_player: !input default_player
      shuffle: '{{ shuffle | default(false, true) | bool(false) }}'
      
      # Player Logik (Standard Blueprint Logik)
      player_data: >
        {% set ma = integration_entities('music_assistant') %}
        {% set ma_names = ma | map('state_attr', 'friendly_name') | list %}
        {% set ns = namespace(players=[]) %} 
        {% for player in media_player | default([], true) %}
          {% if player in ma %}
            {% set ns.players = ns.players + [player] %}
          {% elif player in ma_names %}
            {% set entity = ma | select('is_state_attr', 'friendly_name', player) | list %}
            {% set ns.players = ns.players + entity %}
          {% endif %}
        {% endfor %}
        {{ ns.players }}
      target_data:
        area_id: '{{ area | default(''NA'', true) }}'
        entity_id: '{{ ''NA'' if area | default and not player_data else (player_data or default_player) | default(''NA'', true) }}'

  # Validierung des Targets
  - if:
      - condition: template
        value_template: '{{ not (area | default or player_data or default_player) }}'
    then:
      - stop: No valid target for Music Assistant Voice script found

# -----------------------------------------------------------
  # POWER MANAGEMENT (Erweitert: Löst auch Räume auf!)
  # -----------------------------------------------------------
  - variables:
      # 1. Map
      player_power_map:
        "media_player.squeezeplay_b8_27_eb_64_0b_40": "switch.musik_bad"
        "media_player.squeezeplay_kea_wlan": "switch.musik_kea"
        "media_player.squeezeplay_1c_bf_ce_3d_17_3e": "switch.musik_kuche"
        "media_player.squeezeplay_00_0f_53_84_36_34": "switch.musik_schlafzimmer"  
        "media_player.squeezeplay_emil": "switch.hobbykeller_musik_und_medien"  
        "media_player.squeezeplay_waschkeller": "switch.musik_waschkeller"  
        "media_player.squeezeplay_wohnzimmer": "switch.musikwohnzimmer"



      # 2. Wir suchen alle betroffenen Player (auch die im Raum!)
      power_target_players: >
        {% set ns = namespace(all=[]) %}
        
        {# A. Direkt genannte Player (vom LLM) #}
        {% if player_data %}
          {% set ns.all = ns.all + player_data %}
        {% endif %}

        {# B. Player im genannten Raum suchen #}
        {% if area %}
          {# Liste aller MA-Player im System #}
          {% set all_ma = integration_entities('music_assistant') %}
          {% for area_id in area %}
            {# Finde alle Entities im Raum, die AUCH MA-Player sind #}
            {% set area_players = area_entities(area_id) | select('in', all_ma) | list %}
            {% set ns.all = ns.all + area_players %}
          {% endfor %}
        {% endif %}
        
        {# C. Fallback auf Default Player #}
        {% if ns.all | length == 0 and default_player %}
           {% set ns.all = [default_player] %}
        {% endif %}
        
        {{ ns.all | unique | list }}

  # 3. Schleife über alle gefundenen Player -> Schalter anmachen
  - repeat:
      for_each: "{{ power_target_players }}"
      sequence:
        - variables:
            assigned_switch: "{{ player_power_map.get(repeat.item) }}"
        - if:
            - condition: template
              value_template: "{{ assigned_switch and is_state(assigned_switch, 'off') }}"
          then:
            - action: switch.turn_on
              target:
                entity_id: "{{ assigned_switch }}"

  # -----------------------------------------------------------
  # 1. DIE SUCHE (Läuft während der Speaker bootet)
  # -----------------------------------------------------------
  - action: music_assistant.search
    data:
      config_entry_id: "01JNPPZFB87GV8RBG5ARMMMY2F"
      name: "{{ media_id }}"
      media_type: 
        - "{{ media_type }}"
      limit: 5
    response_variable: raw_result

  # -----------------------------------------------------------
  # 2. DATENAUFBEREITUNG (Fix für "Unknown" Artist & URIs)
  # -----------------------------------------------------------
  - variables:
      play_continuously: !input play_continuously
      
      # Schritt A: URI berechnen 
      found_uri: >
        {# LOGIK FÜR PODCASTS (iTunes Filter) #}
        {% if media_type == 'podcast' %}
          {% set pods = raw_result.podcasts | default([]) %}
          {% set matches = pods | selectattr('uri', 'match', '^itunes') | list %}
          {{ matches[0].uri if matches | length > 0 else 'NA' }}

        {# LOGIK FÜR AUDIOBOOKS (Nimm ersten Treffer) #}
        {% elif media_type == 'audiobook' %}
          {% set books = raw_result.audiobooks | default([]) %}
          {{ books[0].uri if books | length > 0 else 'NA' }}

        {% else %}
          NA
        {% endif %}

      # Schritt B: Das Paket schnüren
      action_data:
        # FIX: Wenn Artist "Unknown" ist, setzen wir "NA"
        artist: >
          {% if artist in ['Unknown', 'unknown', 'None', ''] %}
            NA
          {% else %}
            {{ artist | default('NA', true) }}
          {% endif %}

        album: '{{ album | default(''NA'', true) }}'
        
        # Typ setzen (Override nur bei gefundenem iTunes Podcast/Audiobook URI)
        media_type: >
          {{ media_type if found_uri != 'NA' else media_type }}
        
        # ID setzen
        media_id: >
          {{ found_uri if found_uri != 'NA' else (media_id.split(';')[0] | trim) }}
          
        # radio_mode MUSS 'NA' sein für Podcast UND Audiobook
        radio_mode: >
           {% if found_uri != 'NA' or media_type in ['podcast', 'audiobook'] %}
             NA
           {% else %}
             {{ false if play_continuously == 'Never' else play_continuously == 'Always' and media_type != 'radio' or 'NA' }}
           {% endif %}

  # -----------------------------------------------------------
  # 3. WARTEN AUF PLAYER (Boot-Check)
  # -----------------------------------------------------------
  - repeat:
      for_each: >
        {% set targets = target_data.entity_id %}
        {{ targets if targets is list else [targets] }}
      sequence:
        # Wir warten, bis der Player NICHT mehr 'unavailable' ist (Max 45s)
        - wait_template: "{{ not is_state(repeat.item, 'unavailable') }}"
          timeout: "00:00:45"
          continue_on_timeout: true

  # Abspielen
  - alias: Play music/podcast using Music Assistant
    action: music_assistant.play_media
    data: '{{ dict(action_data.items() | rejectattr(''1'', ''eq'', ''NA'')) }}'
    target: '{{ dict(target_data.items() | rejectattr(''1'', ''eq'', ''NA'')) }}'

  # Shuffle setzen
  - alias: Enable/Disable shuffle
    action: media_player.shuffle_set
    data:
      shuffle: '{{ shuffle }}'
    target: '{{ dict(target_data.items() | rejectattr(''1'', ''eq'', ''NA'')) }}'
  
  # Zusätzliche Aktionen
  - sequence: !input actions