blueprint:
  name: LLM Script for Music Assistant voice requests
  source_url: https://github.com/markist/voice-support/blob/main/llm-script-blueprint/llm_voice_script.yaml
  description: Script with Auto-Power-On (Registry Fix), Audiobook & Podcast Logic.
  domain: script
  author: TheFes (Modified by Gemini)
  homeassistant:
    min_version: 2024.6.0
  input:
    music_assistant_entry_id:
      name: Music Assistant Integration ID
      description: "Die ID deiner Music Assistant Integration (z.B. 01JNPPZFB87GV8RBG5ARMMMY2F)."
      selector:
        text: {}
      default: "01JNPPZFB87GV8RBG5ARMMMY2F"

    music_assistant_settings:
      name: Settings for Music Assistant playback
      icon: mdi:music
      description: Configure Music Assistant playback.
      input:
        default_player:
          name: Default Player
          description: Default MA player if none specified.
          selector:
            entity:
              filter:
              - integration: music_assistant
                domain:
                - media_player
              multiple: false
          default:
        play_continuously:
          name: Radio Mode
          description: Radio Mode settings.
          selector:
            select:
              options:
              - Use player settings
              - Always
              - Never
              multiple: false
              custom_value: false
              sort: false
          default: Use player settings
    prompt_settings:
      name: Prompt settings for the LLM
      icon: mdi:robot
      description: Fine-tune prompts.
      collapsed: true
      input:
        media_type_prompt:
          name: Media Type Prompt
          description: Prompt for media_type.
          selector:
            text:
              multiline: true
              multiple: false
          default: 'Mandatory! Values: track, album, artist, playlist, radio, podcast, audiobook. Default: playlist.'
        artist_prompt:
          name: Artist Prompt
          description: Prompt for artist.
          selector:
            text:
              multiline: true
              multiple: false
          default: '"artist" is the requested artist, host, or author. If unknown, use empty string.'
        album_prompt:
          name: Album Prompt
          description: Prompt for album.
          selector:
            text:
              multiline: true
              multiple: false
          default: '"album" is the requested album. If unknown, use empty string.'
        media_id_prompt:
          name: Media ID Prompt
          description: Prompt for media_id.
          selector:
            text:
              multiline: true
              multiple: false
          default: 'Mandatory! provide specific name (track, album, podcast name, audiobook title).'
        media_description_prompt:
          name: Media Description Prompt
          description: Prompt for media description.
          selector:
            text:
              multiline: true
              multiple: false
          default: Description of media to be played.
        area_prompt:
          name: Area Prompt
          description: Prompt for area.
          selector:
            text:
              multiline: true
              multiple: false
          default: The area(s) for the request.
        media_player_prompt:
          name: Media Player Prompt
          description: Prompt for media player.
          selector:
            text:
              multiline: true
              multiple: false
          default: Only use if specifically mentioned. Must be MA entity_id.
        shuffle_prompt:
          name: Shuffle Prompt
          description: Prompt for shuffle.
          selector:
            text:
              multiline: true
              multiple: false
          default: 'Mandatory! True if shuffle requested. False for Podcasts/Audiobooks.'
    addition_conditions_actions:
      name: Additional actions
      icon: mdi:wrench
      description: Additional actions after playback starts.
      collapsed: true
      input:
        actions:
          name: Additional actions
          selector:
            action: {}
          default: []
mode: parallel
max_exceeded: silent
description: Play music based on voice request (Auto-Power & Logic Fixes).
fields:
  media_type:
    selector:
      select:
        options:
        - track
        - album
        - artist
        - playlist
        - radio
        - podcast
        - audiobook
    name: Media Type
    description: !input media_type_prompt
    required: true
  artist:
    selector:
      text:
    name: Artist
    description: !input artist_prompt
    required: true
  album:
    selector:
      text:
    name: Album
    description: !input album_prompt
    required: true
  media_id:
    selector:
      text:
    name: Media ID
    description: !input media_id_prompt
    required: true
  media_description:
    selector:
      text:
    name: Media Description
    description: !input media_description_prompt
    required: true
  area:
    selector:
      area:
        entity:
          integration: music_assistant
          domain: media_player
        multiple: true
    name: Area
    description: !input area_prompt
  media_player:
    selector:
      entity:
        filter:
          integration: music_assistant
          domain: media_player
        multiple: true
    name: Media Player
    description: !input media_player_prompt
  shuffle:
    selector:
      boolean:
    name: Shuffle
    description: !input shuffle_prompt
sequence:
  # -----------------------------------------------------------
  # 1. KONFIGURATION (Hier wird die Map definiert!)
  # -----------------------------------------------------------
  - variables:
      mass_config_id: !input music_assistant_entry_id
      
      # WICHTIG: Diese Definition muss GANZ OBEN stehen!
      player_power_map:
        "media_player.squeezeplay_1c_bf_ce_3d_17_3e": "switch.musik_kuche"
        "media_player.squeezeplay_00_0f_53_84_36_34": "switch.musik_schlafzimmer"
        "media_player.squeezeplay_b8_27_eb_64_0b_40": "switch.musik_bad"
        "media_player.squeezeplay_kea_wlan": "switch.musik_kea"
        "media_player.squeezeplay_emil": "switch.hobbykeller_musik_und_medien"
        "media_player.squeezeplay_waschkeller": "switch.musik_waschkeller"
        "media_player.squeezeplay_wohnzimmer": "switch.musikwohnzimmer"
        "media_player.voicetest": "switch.voicetest_strom"

      # Standard Variablen
      version: 20250106
      default_player: !input default_player
      shuffle: '{{ shuffle | default(false, true) | bool(false) }}'

  # -----------------------------------------------------------
  # 2. PLAYER LOGIK (Wer ist gemeint?)
  # -----------------------------------------------------------
  - variables:
      player_data: >
        {% set ma = integration_entities('music_assistant') %}
        {% set ma_names = ma | map('state_attr', 'friendly_name') | list %}
        {% set ns = namespace(players=[]) %} 
        {% for player in media_player | default([], true) %}
          {% if player in ma %}
            {% set ns.players = ns.players + [player] %}
          {% elif player in ma_names %}
            {% set entity = ma | select('is_state_attr', 'friendly_name', player) | list %}
            {% set ns.players = ns.players + entity %}
          {% endif %}
        {% endfor %}
        {{ ns.players }}
      target_data:
        area_id: '{{ area | default(''NA'', true) }}'
        entity_id: '{{ ''NA'' if area | default and not player_data else (player_data or default_player) | default(''NA'', true) }}'

  # Validierung
  - if:
      - condition: template
        value_template: '{{ not (area | default or player_data or default_player) }}'
    then:
      - stop: No valid target for Music Assistant Voice script found

  # -----------------------------------------------------------
  # 3. POWER MANAGEMENT (Hier wurde der Fehler geworfen)
  # -----------------------------------------------------------
  - variables:
      power_target_players: >
        {% set ns = namespace(all=[]) %}
        
        {# A. Direkt genannte Player #}
        {% if player_data %}
          {% set ns.all = ns.all + player_data %}
        {% endif %}

        {# B. Player im genannten Raum suchen (via Registry Lookup) #}
        {% if area %}
           {# 1. Echte Entity-IDs aus dem Raum holen #}
           {% set entities_in_area = namespace(list=[]) %}
           {% for area_uuid in area %}
              {% set entities_in_area.list = entities_in_area.list + area_entities(area_uuid) %}
           {% endfor %}

           {# 2. Prüfen: Ist einer unserer Map-Player in diesem Raum? #}
           {# HIER passierte der Fehler, weil player_power_map fehlte #}
           {% for player_key in player_power_map.keys() %}
              {% if player_key in entities_in_area.list %}
                  {% set ns.all = ns.all + [player_key] %}
              {% endif %}
           {% endfor %}
        {% endif %}
        
        {# C. Fallback #}
        {% if ns.all | length == 0 and default_player %}
           {% set ns.all = [default_player] %}
        {% endif %}
        
        {{ ns.all | unique | list }}

  # Strom einschalten
  - repeat:
      for_each: "{{ power_target_players }}"
      sequence:
        - variables:
            assigned_switch: "{{ player_power_map.get(repeat.item) }}"
        - if:
            - condition: template
              value_template: "{{ assigned_switch and is_state(assigned_switch, 'off') }}"
          then:
            - action: switch.turn_on
              target:
                entity_id: "{{ assigned_switch }}"

  # -----------------------------------------------------------
  # 1. DIE SUCHE
  # -----------------------------------------------------------
  - action: music_assistant.search
    data:
      config_entry_id: "{{ mass_config_id }}"
      name: "{{ media_id }}"
      media_type: 
        - "{{ media_type }}"
      limit: 5
    response_variable: raw_result

  # -----------------------------------------------------------
  # 2. DATENAUFBEREITUNG
  # -----------------------------------------------------------
  - variables:
      play_continuously: !input play_continuously
      
      # Schritt A: URI berechnen 
      found_uri: >
        {% if media_type == 'podcast' %}
          {% set pods = raw_result.podcasts | default([]) %}
          {% set matches = pods | selectattr('uri', 'match', '^itunes') | list %}
          {{ matches[0].uri if matches | length > 0 else 'NA' }}
        {% elif media_type == 'audiobook' %}
          {% set books = raw_result.audiobooks | default([]) %}
          {{ books[0].uri if books | length > 0 else 'NA' }}
        {% else %}
          NA
        {% endif %}

      # Schritt B: Das Paket schnüren
      action_data:
        artist: >
          {% if artist in ['Unknown', 'unknown', 'None', ''] %}
            NA
          {% else %}
            {{ artist | default('NA', true) }}
          {% endif %}
        album: '{{ album | default(''NA'', true) }}'
        media_type: >
          {{ media_type if found_uri != 'NA' else media_type }}
        media_id: >
          {{ found_uri if found_uri != 'NA' else (media_id.split(';')[0] | trim) }}
        radio_mode: >
           {% if found_uri != 'NA' or media_type in ['podcast', 'audiobook'] %}
             NA
           {% else %}
             {{ false if play_continuously == 'Never' else play_continuously == 'Always' and media_type != 'radio' or 'NA' }}
           {% endif %}

  # -----------------------------------------------------------
  # 3. WARTEN AUF PLAYER
  # -----------------------------------------------------------
  - repeat:
      for_each: "{{ power_target_players }}"
      sequence:
        - wait_template: "{{ not is_state(repeat.item, 'unavailable') }}"
          timeout: "00:00:45"
          continue_on_timeout: true

  # Abspielen
  - alias: Play music/podcast using Music Assistant
    action: music_assistant.play_media
    data: '{{ dict(action_data.items() | rejectattr(''1'', ''eq'', ''NA'')) }}'
    target: '{{ dict(target_data.items() | rejectattr(''1'', ''eq'', ''NA'')) }}'

  # Shuffle setzen
  - alias: Enable/Disable shuffle
    action: media_player.shuffle_set
    data:
      shuffle: '{{ shuffle }}'
    target: '{{ dict(target_data.items() | rejectattr(''1'', ''eq'', ''NA'')) }}'
  
  # Zusätzliche Aktionen
  - sequence: !input actions